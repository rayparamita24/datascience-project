# -*- coding: utf-8 -*-
"""Thyroid.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gshIGfMwmSLO53BT7q2HHH6OGY0uXAcw
"""

import cv2
import numpy as np
import matplotlib.pyplot as plt
from skimage.feature import graycomatrix, graycoprops
image_path = '/content/14.jpg'  # replace with your image path
image = cv2.imread(image_path)
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
# Display the grayscale image
plt.imshow(gray_image, cmap='gray')
plt.title('Grayscale Image')
plt.show()

# Apply Gaussian blur to reduce noise
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)

# Enhance contrast using histogram equalization
equalized_image = cv2.equalizeHist(blurred_image)

# Display the preprocessed image
plt.imshow(equalized_image, cmap='gray')
plt.title('Preprocessed Image')
plt.show()
# Edge detection using Canny
edges = cv2.Canny(equalized_image, 100, 200)

# Find contours
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Draw contours on the original image
contour_image = image.copy()
cv2.drawContours(contour_image, contours, -1, (0, 255, 0), 2)

# Display the image with contours
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title('Contours')
plt.show()
largest_contour = max(contours, key=cv2.contourArea)
area = cv2.contourArea(largest_contour)

# Calculate perimeter
perimeter = cv2.arcLength(largest_contour, True)

# Calculate shape features
x, y, w, h = cv2.boundingRect(largest_contour)
aspect_ratio = float(w) / h
rect_area = w * h
extent = float(area) / rect_area
 # Determine shape and margin
shape = "irregular" if aspect_ratio < 0.8 or aspect_ratio > 1.2 else "round/oval"
margin = "irregular" if not cv2.isContourConvex(largest_contour) else "smooth"
print(f"Area: {area}")
print(f"Perimeter: {perimeter}")
print(f"Aspect Ratio: {aspect_ratio}")
print(f"Extent: {extent}")
print(f"Shape: {shape}")
print(f"Margin: {margin}")

def extract_advanced_features(image, contour):
    # Calculate basic shape features
    area = cv2.contourArea(contour)
    perimeter = cv2.arcLength(contour, True)
    x, y, w, h = cv2.boundingRect(contour)
    aspect_ratio = float(w) / h
    rect_area = w * h
    extent = float(area) / rect_area

    # Calculate texture features using GLCM
    glcm = graycomatrix(image, distances=[5], angles=[0], symmetric=True, normed=True)
    contrast = graycoprops(glcm, 'contrast')[0, 0]
    dissimilarity = graycoprops(glcm, 'dissimilarity')[0, 0]
    homogeneity = graycoprops(glcm, 'homogeneity')[0, 0]
    energy = graycoprops(glcm, 'energy')[0, 0]
    correlation = graycoprops(glcm, 'correlation')[0, 0]

    # Echogenicity (mean intensity)
    mean_intensity = np.mean(image)
    echogenicity = "hypoechoic" if mean_intensity < 100 else "isoechoic" if mean_intensity < 200 else "hyperechoic"

    # Calcifications detection (simple rule based on high intensity spots)
    calcifications = "microcalcifications" if np.any(image > 200) else "none"

    # Dummy vascularity data (replace with actual analysis)
    vascularity = "none"  # Replace with actual vascularity analysis

    # Return all features as a dictionary
    features = {
        'size': max(w, h),
        'shape': shape,
        'margin': margin,
        'area': area,
        'perimeter': perimeter,
        'aspect_ratio': aspect_ratio,
        'extent': extent,
        'contrast': contrast,
        'dissimilarity': dissimilarity,
        'homogeneity': homogeneity,
        'energy': energy,
        'correlation': correlation,
        'mean_intensity': mean_intensity,
        'echogenicity': echogenicity,
        'calcifications': calcifications,
        'vascularity': vascularity
    }
    return features

# Assuming the largest contour is the thyroid nodule
largest_contour = max(contours, key=cv2.contourArea)

# Extract features
features = extract_advanced_features(equalized_image, largest_contour)

# Print extracted features
for key, value in features.items():
    print(f"{key}: {value}")




  # Simple decision rule for classification (example only)
def classify_nodule(features):
    # Example thresholds (these should be based on clinical data and training)
    if features['echogenicity'] == "hypoechoic" and features['calcifications'] == "microcalcifications" and features['shape'] == "irregular":
        return "Malignant"
    else:
        return "Benign"

# Classify the nodule
classification = classify_nodule(features)
print(f"Nodule Classification: {classification}")
report = f"""
Thyroid Ultrasound Report

Nodule Characteristics:
- Size: {features['size']} mm
- Shape: {features['shape']}
- Margin: {features['margin']}
- Echogenicity: {features['echogenicity']}
- Composition: Solid (dummy data, replace with actual analysis)
- Calcifications: {features['calcifications']}
- Vascularity: {features['vascularity']}

Quantitative Features:
- Area: {features['area']}
- Perimeter: {features['perimeter']}
- Aspect Ratio: {features['aspect_ratio']}
- Extent: {features['extent']}
- Contrast: {features['contrast']}
- Dissimilarity: {features['dissimilarity']}
- Homogeneity: {features['homogeneity']}
- Energy: {features['energy']}
- Correlation: {features['correlation']}
- Mean Intensity: {features['mean_intensity']}

Classification: {classification}
"""

print(report)







#location



# Load and preprocess the image
image = cv2.imread(image_path)
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
equalized_image = cv2.equalizeHist(blurred_image)

# Segment the image using edge detection and find contours
edges = cv2.Canny(equalized_image, 100, 200)
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Assuming the largest contour is the thyroid nodule
largest_contour = max(contours, key=cv2.contourArea)

# Get the bounding box coordinates of the nodule
x, y, w, h = cv2.boundingRect(largest_contour)
nodule_location = (x, y, w, h)

# Draw the bounding box on the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)

# Display the image with the nodule bounding box
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title('Nodule Location')
plt.show()

# Print the nodule location coordinates
print(f"Nodule Location (x, y, width, height): {nodule_location}")


# Extract the nodule region
nodule_region = gray_image[y:y+h, x:x+w]
# Analyze the region around the nodule to detect the halo
halo_detected = False
halo_thickness = 5  # Adjust the halo thickness based on your image characteristics
halo_region = gray_image[max(0, y-halo_thickness):min(gray_image.shape[0], y+h+h+halo_thickness), max(0, x-halo_thickness):min(gray_image.shape[1], x+w+halo_thickness)]
# Calculate the mean intensity of the nodule and the halo region
mean_nodule_intensity = np.mean(nodule_region)
mean_halo_intensity = np.mean(halo_region) - mean_nodule_intensity
# Define a threshold to detect the halo (this threshold might need tuning)
halo_threshold = -20

# Check if the mean halo intensity indicates a hypoechoic ring
if mean_halo_intensity < halo_threshold:
    halo_detected = True

# Draw the bounding box and halo on the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
if halo_detected:
    cv2.rectangle(contour_image, (x - halo_thickness, y - halo_thickness), (x + w + halo_thickness, y + h + halo_thickness), (255, 0, 0), 2)

# Display the image with the nodule and halo
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title('Nodule and Peripheral Halo')
plt.show()
# Print the nodule location coordinates and halo detection result
print(f"Nodule Location (x, y, width, height): {nodule_location}")
print(f"Peripheral Halo Detected: {halo_detected}")





image = cv2.imread(image_path)
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
equalized_image = cv2.equalizeHist(blurred_image)

# Segment the image using edge detection and find contours
edges = cv2.Canny(equalized_image, 100, 200)
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Assuming the largest contour is the thyroid nodule
largest_contour = max(contours, key=cv2.contourArea)

# Get the bounding box coordinates of the nodule
x, y, w, h = cv2.boundingRect(largest_contour)
nodule_region = gray_image[y:y+h, x:x+w]

# Analyze the composition of the nodule
def analyze_composition(nodule_region):
    # Calculate mean intensity
    mean_intensity = np.mean(nodule_region)

    # Calculate the proportion of pixels above and below certain intensity thresholds
    cystic_threshold = 50
    solid_threshold = 150
    num_pixels = nodule_region.size
    num_cystic_pixels = np.sum(nodule_region < cystic_threshold)
    num_solid_pixels = np.sum(nodule_region > solid_threshold)

    proportion_cystic = num_cystic_pixels / num_pixels
    proportion_solid = num_solid_pixels / num_pixels

    # Determine composition based on thresholds
    if proportion_cystic > 0.7:
        composition = 'Cystic'
    elif proportion_solid > 0.7:
        composition = 'Solid'
    elif 0.3 <= proportion_cystic <= 0.7 and 0.3 <= proportion_solid <= 0.7:
        composition = 'Complex'
    elif proportion_solid > proportion_cystic:
        composition = 'Predominantly Solid'
    else:
        composition = 'Predominantly Cystic'

    return composition

# Identify the composition of the nodule
composition = analyze_composition(nodule_region)

# Draw the bounding box and composition result on the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
cv2.putText(contour_image, composition, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)

# Display the image with the nodule and its composition
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title(f'Nodule Composition: {composition}')
plt.show()

# Print the nodule composition
print(f"Nodule Composition: {composition}")


#Vascularity Analysis

image = cv2.imread(image_path)
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
equalized_image = cv2.equalizeHist(blurred_image)

# Segment the image using edge detection and find contours
edges = cv2.Canny(equalized_image, 100, 200)
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Assuming the largest contour is the thyroid nodule
largest_contour = max(contours, key=cv2.contourArea)

# Get the bounding box coordinates of the nodule
x, y, w, h = cv2.boundingRect(largest_contour)
nodule_region = image[y:y+h, x:x+w]

# Convert the nodule region to HSV to analyze blood flow (Doppler signals are usually in color)
hsv_nodule_region = cv2.cvtColor(nodule_region, cv2.COLOR_BGR2HSV)

# Define a range for the red color (common in Doppler signals for blood flow)
lower_red = np.array([0, 50, 50])
upper_red = np.array([10, 255, 255])
mask1 = cv2.inRange(hsv_nodule_region, lower_red, upper_red)

lower_red = np.array([170, 50, 50])
upper_red = np.array([180, 255, 255])
mask2 = cv2.inRange(hsv_nodule_region, lower_red, upper_red)

# Combine the masks to cover the entire red range
mask = mask1 + mask2

# Calculate the proportion of the nodule region with detected blood flow
blood_flow_area = np.sum(mask > 0)
total_area = mask.size
vascularity_proportion = blood_flow_area / total_area

# Determine the vascularity category based on the proportion
if vascularity_proportion > 0.5:
    vascularity = 'High'
elif 0.2 < vascularity_proportion <= 0.5:
    vascularity = 'Moderate'
else:
    vascularity = 'Low'


# Draw the bounding box and vascularity result on the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
cv2.putText(contour_image, vascularity, (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.9, (0, 255, 0), 2)

# Display the image with the nodule and its vascularity
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title(f'Nodule Vascularity: {vascularity}')
plt.show()

# Print the vascularity result
print(f"Nodule Vascularity: {vascularity}")
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
equalized_image = cv2.equalizeHist(blurred_image)

# Segment the image using edge detection and find contours
edges = cv2.Canny(equalized_image, 100, 200)
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Assuming the largest contour is the thyroid nodule
largest_contour = max(contours, key=cv2.contourArea)

# Get the bounding box coordinates of the nodule
x, y, w, h = cv2.boundingRect(largest_contour)
nodule_region = gray_image[y:y+h, x:x+w]

# Thresholding to detect bright spots (echogenic foci)
# You may need to adjust the threshold value based on the image characteristics
_, thresh_image = cv2.threshold(nodule_region, 200, 255, cv2.THRESH_BINARY)

# Find contours of the bright spots
foci_contours, _ = cv2.findContours(thresh_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Count the number of echogenic foci
num_echogenic_foci = len(foci_contours)

# Draw the bounding box and echogenic foci on the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
for fc in foci_contours:
    fx, fy, fw, fh = cv2.boundingRect(fc)
    cv2.rectangle(contour_image, (x + fx, y + fy), (x + fx + fw, y + fy + fh), (0, 0, 255), 1)

# Display the image with the nodule and echogenic foci
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title(f'Echogenic Foci: {num_echogenic_foci}')
plt.show()

# Print the number of echogenic foci
print(f"Number of Echogenic Foci: {num_echogenic_foci}")


image = cv2.imread(image_path)
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
blurred_image = cv2.GaussianBlur(gray_image, (5, 5), 0)
equalized_image = cv2.equalizeHist(blurred_image)

# Segment the image using edge detection and find contours
edges = cv2.Canny(equalized_image, 100, 200)
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Assuming the largest contour is the thyroid nodule
largest_contour = max(contours, key=cv2.contourArea)

# Get the bounding box coordinates of the nodule
x, y, w, h = cv2.boundingRect(largest_contour)
nodule_region = gray_image[y:y+h, x:x+w]

# Thresholding to detect bright spots (calcifications)
# Adjust the threshold value based on the image characteristics
_, thresh_image = cv2.threshold(nodule_region, 200, 255, cv2.THRESH_BINARY)

# Find contours of the bright spots (calcifications)
calcification_contours, _ = cv2.findContours(thresh_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# Count the number of calcifications
num_calcifications = len(calcification_contours)

# Draw the bounding box and calcifications on the original image
contour_image = image.copy()
cv2.rectangle(contour_image, (x, y), (x + w, y + h), (0, 255, 0), 2)
for cc in calcification_contours:
    cx, cy, cw, ch = cv2.boundingRect(cc)
    cv2.rectangle(contour_image, (x + cx, y + cy), (x + cx + cw, y + cy + ch), (0, 0, 255), 1)

# Display the image with the nodule and calcifications
plt.imshow(cv2.cvtColor(contour_image, cv2.COLOR_BGR2RGB))
plt.title(f'Calcifications: {num_calcifications}')
plt.show()

# Print the number of calcifications
print(f"Number of Calcifications: {num_calcifications}")

# Analyze the size of calcifications to classify them
def classify_calcifications(calcification_contours):
    microcalcifications = 0
    macrocalcifications = 0
    for cc in calcification_contours:
        area = cv2.contourArea(cc)
        if area < 5:  # Adjust threshold based on image resolution
            microcalcifications += 1
        else:
            macrocalcifications += 1
    return microcalcifications, macrocalcifications

micro, macro = classify_calcifications(calcification_contours)
print(f"Microcalcifications: {micro}")
print(f"Macrocalcifications: {macro}")